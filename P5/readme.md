# 五级流水线 CPU 设计方案        
add, sub, ori, lw, sw, beq, lui, jal, jr, nop

错误记录：  
fwd_rt_data_E.sel=0  
fwd_rt_data_E.data0=z 
    fwd_rt_data_D=z



设计流程   
1. 流水线寄存器+单指令功能  
2. 阻塞实现   

    没注明的Tuse为3如sll的Tuse_rs
    |    instr_D     |  reg  | Tuse  |
    | :------------: | :---: | :---: |
    |      beq       | rs/rt |   0   |
    | cal_r - sll_rs | rs/rt |   1   |
    |     cal_i      |  rs   |   1   |
    |      load      |  rs   |   1   |
    |     store      |  rs   |   1   |
    |     store      |  rt   |   2   |
    
    只需考虑 Tnew_E 运算得 Tnew_M Tnew_W 恒等于0
    | instr_D | Tnew  |
    | :-----: | :---: |
    |   beq   |   0   |
    |  cal_r  |   1   |
    |  cal_i  |   1   |
    |  load   |   1   |
    |  store  |   1   |
    |  store  |   2   |

    stall不判断reg_write(若不可写则reg_addr=0)

    冒险控制模块合并于CU_D中

    为了方便处理，课程组要求阻塞是指将指令阻塞在 D 级。
    当一个指令到达 D 级后，我们需要将它的 Tuse值与后面每一级的 Tnew进行比较（当然还有 AA 值的校验），
    当 Tuse < Tnew 时，我们需要阻塞流水线。
    阻塞的实现需要改造流水线寄存器和 PC ，我们需要让它们具有以下功能：

    + 冻结 PC 的值；
    + 冻结 D 级流水线寄存器的值；
    + 将 E 级流水线寄存器清零（这等价于在instr_D前插入了一个 nop 指令）。
    此外，还有一个考虑，就是复位信号和阻塞信号的优先级问题。请仔细设计信号的优先级来保证流水线的正确性。

3. GRF内部转发实现
4. 转发实现     
    
    + 罗列需求者流水寄存器 rs rt      

        |     D     |     E     |     M     |
        | :-------: | :-------: | :-------: |
        | rs_data_D | rs_data_E | rt_data_M |
        | rt_data_D | rt_data_E |           |

    + 各级供给者流水线寄存器选择转发结果 MUX_1      

        add, sub, ori, lw, sw, beq, lui, jal, jr, nop       
        供给者 jal  pc_W+8

    + 需求者流水线寄存器从其后级的接收到的转发结果中选择 MUX_2
    
        ori $t0, $0, 2      
        add $t1, $t0, $t0       
        nop     
        sw $t1, 0($0) tuse=2        
   
5. 测试优化

    lui计算可在D的EXT内完成 但我在ALU中完成     
    NPC 可以分离到 D 层中

在设计时，可以利用这一点，按照流水级的顺序对每一级的流水寄存器进行实例化，然后在其间插入相应级的模块，并用注释清晰地注明各级起始位置。
另外，也可以考虑增加模块层次，将每一流水级的各个模块放入一个父级模块中调用，可以将复杂度有效分散到各个层级。

## stage_F
PC  
IM  

## stage_D
D_reg       
CU_D     
MUX_8(GRF_reg_data)     
GRF 有 stage_W 写回部分
EXT

## stage_E
E_reg
CU_E
ALU

## stage_M
DM display 输出`字地址`而非`字节地址`
## stage_W

## CU 概述

分布式译码：每一级都部署一个控制器，负责译出当前级所需控制信号。这种方法较为灵活，“现译现用”有效降低了流水级间传递的信号量，但是需要实例化多个控制器，增加了后续流水级的逻辑复杂度。

控制信号驱动型：为每个指令定义一个 wire 型变量，使用或运算描述组合逻辑，对每个控制信号进行单独处理。这种方法在指令数量较多时适用，且代码量易于压缩，缺陷是如错添或漏添了某条指令，很难锁定出现错误的位置。

指令存储器（IM，instruction memory）和数据存储器（DM，data memory）要求如下：

IM：容量为 16KiB（4096 × 32bit）。
DM：容量为 12KiB（3072 × 32bit）。
PC 的初始地址为 0x00003000，和 Mars 中我们要求设置的代码初始地址相同。


![图 1](images/mips.png)  


# 思考题

1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？

3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？

4、我们为什么要使用 GPR 内部转发？该如何实现？

5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

7、简要描述你的译码器架构，并思考该架构的优势以及不足。

1、[P5 选做] 请详细描述你的测试方案及测试数据构造策略。

2、[P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。